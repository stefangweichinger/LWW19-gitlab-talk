<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <title>the pipeline</title>
    <style>
     @import url(http://fonts.googleapis.com/css?family=Lobster);
     @import url(http://fonts.googleapis.com/css?family=IBM+Plex+Mono);
     @import url(http://fonts.googleapis.com/css?family=IBM+Plex+Serif);

      body { font-family: 'IBM Plex Serif'; }
      h1, h2, h3 {
          font-family: 'Lobster';
          font-weight: normal;
      }
      a {
          background-color: #fafa00;
          color: #000;
          text-decoration: none;
      }
      .center {
          margin: 0 auto;
      }
      .footnote {
          position: absolute;
          bottom: 3em;
          font-family: 'IBM Plex Serif';
      }
      .inverse {
      background-color: #333;
      color: #fff;
      vertical-align: middle;
      text-align: left;
      }
      .inverse .remark-slide-number {
          display: none;
      }

      .red {
          color: #fa0000;
      }
      .remark-code, .remark-inline-code {
          font-family: 'IBM Plex Mono';
        font-size: 0.7em; }
  </style>
</head>
<body>
  <textarea id="source">
class: center, middle, inverse

# the pipeline

## CI/CD with GitLab

.footnote[Stefan G. Weichinger, oops linux, 2019]

---
class: center, middle
# Intro
---

# the pipeline
## CI/CD in GitLab (CE)
### an overview by Stefan G. Weichinger

at #LWW19 LinuxWochenWien 2019

.created-on[2019-05-02]
---
.head[
  # Agenda
]
1. About GitLab
  1. What is GitLab?
  1. Community or Enterprise?
  1. Installation options
1. GitLab environment
  1. Overview
  1. the Server
  1. the Runner
1. Setup a project with CI/CD
  1. Create the project in gitlab
  1. Enable CI
  1. Run your Docker image
1. GitLab CI/CD "for runaways"
  1. Build versioned releases
  1. best practises
1. optional demo

---
.head[
  # About GitLab
  ## What is GitLab?
]
GitLab is an open source end-to-end software development platform with

- built-in version control
--

- issue tracking
--

- code review
--

- CI/CD
--

- ... and much more.

---
.head[
  # About GitLab
  ## Community or Enterprise?
]

There's a Community Edition (CE) and a Enterprise Edition (EE).
The EE has some extra features, but the CE is already very complete.

Development of both versions is done in the public.
---
.head[
  ## About GitLab

  ### use it at https://gitlab.com (and pay for it)
  ### or look for a hoster
  ### or install it on your own systems
]

 * Packages for common Linux distributions.
 * Docker images ... for GitLab CE and for the GitLab Runner.

Basically you might run both the server and the runner on your laptop.red[*]

.footnote[.red[*] ... a bit tricky, though ... DNS etc
]

---
.head[
  # GitLab environment
  ## Overview
]
<img src="overview.svg" width="95%" style="position: fixed; top: 70px; left: 0;" />
---
.head[
  ## GitLab environment :: GitLab Server
]

  ... install GitLab CE Omnibus package on your server

  ... or sign in at gitlab.com

  ... or run it with docker:

```shell
sudo docker run --detach \
	--hostname gitlab.example.com \
	--publish 443:443 --publish 80:80 --publish 22:22 \
	--name gitlab \
	--restart always \
	--volume /srv/gitlab/config:/etc/gitlab \
	--volume /srv/gitlab/logs:/var/log/gitlab \
	--volume /srv/gitlab/data:/var/opt/gitlab \
	gitlab/gitlab-ce:latest
```

or google for a nice docker-compose.yml ...

---
name: runner
class: center, middle
# If you don't need CI/CD ... you are done!
---
.head[
  ## GitLab CI/CD :: the Runner
]

### What?

A Runner can be a virtual machine, a VPS, a bare-metal machine,
a docker container or even a cluster of containers.

---
.head[
  ## GitLab environment :: the Runner
]

### Where?
A runner might be set up to be specific for certain projects, groups or tags.

In general you deploy the runner(s) separated from the GitLab server itself:
High load tasks are separated from the GitLab GUI and logic ... performance high

Runners fetch their jobs and deliver results and (optional) artefacts.

???

runners are separate workhorses
http API between gitlab server and runners

---
.head[
  ## GitLab environment :: Register the Runner
]
Navigate to "Admin Area (<i class="fa fa-wrench" aria-hidden="true"></i>) / Runner" and copy the registration token.

Start a shell in the `runner` container and execute registration:

```shell
$ docker-compose exec runner /bin/bash
root@runner:/# gitlab-runner register
```

Answer the questions:

 * URL: http://gitlab.example.com:10080/ci
 * gitlab-ci token: paste your token
 * Runner description: runner for docker builds
 * Tags: docker-builder
 * Executor: docker
 * default Docker image: docker:1.11.2 (use same version as docker daemon)

Refresh the `Admin Area` page in your browser. It should list you Runner.
---
.head[
  ## GitLab environment :: Configure the Runner
]
Edit the Runners configuration:

```shell
root@runner:/# vim /etc/gitlab-runner/config.toml
```

Access the docker.socket within the runner-container:

```patch
---    volumes = ["/cache"]
+++    volumes = ["/var/run/docker.sock:/var/run/docker.sock", "/cache"]
```

### Note: for "docker-in-docker" the docker runners need:

```patch
--- 
+++    privileged = true
```

Dozens of options here, for example DNS servers ...

---
.head[
  ## Setup a Project :: Create the project in gitlab
]

standard git-procedure ...

```shell
$ git clone https://gitlab.com/stefangweichinger/hello-world
$ cd hello-world
# create great code here
$ git add. ; git commit -m "my great work"; git push
```

Reload the project page and check content.
---
.head[
  ## CI/CD :: enable the magic
]
The CI is configured by creating a `.gitlab-ci.yml` in the root path of your project:

  ### Add a build job to the CI
```yaml
variables:
  IMAGE_NAME: gitlab:5005/sgw/hello-world

before_script:
  - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY

build_latest:
  only:
    - master
  tags:
    - docker-builder
  script:
    - docker build -t $IMAGE_NAME:latest .
    - docker push $IMAGE_NAME:latest
```
`add`, `commit` and `push` this file to the repository.

Watch the build live on your GitLab and check the Registry for the built image.
---
.head[
  # Run your Docker Image
]
Authenticate to the registry:

```shell
$ docker login gitlab:5005
```

Then run your image:

```shell
$ docker run -p 3000:3000 gitlab:5005/sgw/hello-world:latest
```

Access the application in your web browser:

http://gitlab:3000
---
.head[
  # Build versioned releases
]
If we want to build images for release we could use a second build job:

```yaml
build_release:
  only:
    - /^\d+\.\d+/
  tags:
    - docker-builder
  script:
    - docker build -t $IMAGE_NAME:$CI_BUILD_REF_NAME .
    - docker push $IMAGE_NAME:$CI_BUILD_REF_NAME
```

After `commit` and `push` this change tag a version:

```shell
$ git tag 1.0
$ git push --tags
```

Check the build and registry within GitLab.
---
class: center, middle, inverse
 # that was the easy part
---
.head[
  ### ... for runaways
]
# what else can we do?

- you will need routing and SSL/TLS ... something like [traefik](#traefik)
--

- GitLab docker registry: push/pull generated images
--

- CD: deploy to staging and production -> [environments](#environments)
--

- speed up things with [caching](#caching)
--

---
.head[
  # best practises
]

## use variables = avoid hardcoding

gl offers variables for nearly(?) everything

```example
export CI_JOB_TOKEN="abcde-1234ABCD5678ef"
export CI_REGISTRY="registry.example.com"
```

```code
# .gitlab-ci.yml
before_script:
  - echo -n $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY
```

---
.head[
  # best practises
]

## use variables = avoid hardcoding

for example for tagging the docker images:

```example
export CI_COMMIT_SHA="1ecfd275763eff1d6b4844ea3168962458c9f27a"
export CI_COMMIT_SHORT_SHA="1ecfd275"
export CI_COMMIT_REF_NAME="master"
export CI_REGISTRY_IMAGE="registry.example.com/gitlab-org/gitlab-ce"
export CI_REGISTRY="registry.example.com"
export CI_REGISTRY_USER="gitlab-ci-token"
export CI_REGISTRY_PASSWORD="longalfanumstring"
export CI_REGISTRY_IMAGE="registry.example.com/gitlab-org/gitlab-ce"
```

```code
# .gitlab-ci.yml
  script:
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    # Then we tag it "latest"
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    # And we push it.
    - docker push $CI_REGISTRY_IMAGE:latest
```

---
name: caching
.head[
  # best practises
]

## use caches

You can define which paths you want to cache for the next stage(s):

```code
example-job:
  stage: example
  script:
    - npm install
  cache:
    paths:
      - node_modules/
```

For bigger environments you can run a separate cache server and share cache between multiple runners.

---
.head[
  # best practises
]

### use small docker images ... and cache them

instead of rebuilding everytime from scratch

```code
docker build --tag $CONTAINER_IMAGE:$CI_BUILD_REF .
```

you could benefit from the already available docker image layers via

```code
docker build\
  --cache-from $CONTAINER_IMAGE:latest\
  --tag $CONTAINER_IMAGE:$CI_BUILD_REF\
  --tag $CONTAINER_IMAGE:latest\
  .
```

---
name: yaml_templates
.head[
  ### ... for runaways
]

## yaml templates

`.gitlab-ci.yml` grows fast and gets complex rather soon.

To avoid repeating blocks you may use yaml templates, for example:

"deploy to production" and "deploy to staging" might only differ in small parts

```code
docker build\
  --cache-from $CONTAINER_IMAGE:latest\
  --tag $CONTAINER_IMAGE:$CI_BUILD_REF\
  --tag $CONTAINER_IMAGE:latest\
  .
```
---
name: environments
.head[
  ### ... for runaways
]

## environments

Environments are like tags for your CI jobs, describing where code gets deployed.

Deployments are created when jobs deploy versions of code to environments, so every environment can have one or more deployments.

GitLab provides a full history of your deployments for each environment.

GitLab keeps track of your deployments, so you always know what is currently being deployed on your servers

---
name: demo
.head[
  ### a small demo
]

demo repository at gitlab.com : [hello-world](https://gitlab.com/stefangweichinger/hello-world)

???

small python script
CI builds docker image, pushes to project repo

2 environments

---

# Thanks

For more information please contact:

Stefan G. Weichinger &lt;<a href="mailto:office@oops.co.at">office@oops.co.at</a>&gt;

# @stefangw

- expert
- linux servers since the early 90s
- giving talks, writing for magazines, books ...
- always looking for paid work

.bg[ ![Buster JS](https://www.oops.co.at/css/img/oops-logo.gif) ]

---
class: center, middle, inverse

one last thing

---
class: center, middle, inverse
# please vote

---

---
.head[
  # Appendix
]

presentation: done with [remark](https://github.com/gnab/remark)

slides: https://github.com/stefangweichinger/LWW19-gitlab-talk

... and maybe someday on https://gitlab.com/stefangweichinger :smirk:

done by Stefan G. Weichinger &lt;<a href="mailto:office@oops.co.at">office@oops.co.at</a>&gt;

for the [LWW19 - LinuxWochenWien](https://linuxwochen.at)

### links

 * consult your local search engine ... hundreds of articles and howtos ...


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
